% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spec.R
\name{mspec_new}
\alias{mspec_new}
\alias{mspec_empty}
\alias{mspec_add}
\alias{mspec_rmv}
\alias{mspec_sub}
\alias{mspec_describe}
\title{Create, edit, and combine model specifications}
\usage{
mspec_new(name = "Model 1", ...)

mspec_empty(name = "Model 0")

mspec_add(mspec, ..., name = NULL)

mspec_rmv(mspec, name, ...)

mspec_sub(mspec, name, ...)

mspec_describe(mspec, verbose = FALSE)
}
\arguments{
\item{name}{(character value). The label that will be used
to describe this model specification}

\item{...}{A set of variable names (separated by commas) that will be
used to adjust estimates in fitted models when this specification is
applied. The values may be supplied with or without quotation marks
around the variable names (e.g., 'x' or x).}

\item{parent}{This parameters if only used for \code{mspec_add},
\code{mspec_rmv}, and \code{mspec_sub}. The parent \code{mspec_apri} object passes
it's control variables to the descendant, accounting for modifications
specified in \code{...}}
}
\value{
\itemize{
\item \code{mspec_empty()} returns an unadjusted model specification.
\item \code{mspec_new()} returns a model specification
\item \code{mspec_add()}, \code{mspec_rmv()} returns a model specification with the
designated control variables added or removed from the parent
model specification.
\item \code{mspec_sub()} returns a model specification with the designated
control variables (left hand side of the \code{=}) replaced by
variable names supplied by the user (right hand side of the \code{=})
}
}
\description{
\code{mspec_empty()}, \code{mspec_add()}, \code{mspec_rmv()}, and \code{mspec_sub()} are
functions that can be used to create model fitting specifications.
\code{mspec_describe()} is a function that helps clarify model specifications
and facilitates interactive work.
}
\details{
Use \code{mspec_empty()} to create a generic unadjusted specification.
Use \code{mspec_add()}, \code{mspec_rmv()}, and \code{mspec_sub()} to create descendant
model specifications, and use \code{mspec_describe()} to summarize the structure
of the model specifications in a concise manner that accounts for
their dependencies (see examples).
}
\examples{


# Make an unadjusted model
m0  <- mspec_empty("Model 0")

# mspec_describe(mspec) is the same as print(mspec)
mspec_describe(m0)
print(m0)

# Model 1 includes adjustment for sex and class
m1  <- mspec_add(m0, name = "Model 1", sex, pclass)

m1

# Model 2a = model 1 + no. of siblings/spouses
m2a <- mspec_add(m1, name = 'Model 2a', sibsp)

m2a

# Model 2b = model 1 + no. of parents/children
m2b <- mspec_add(m1, name = 'Model 2b', parch)

m2b

# Model 3 = model 1, swapping out class for ticket fare

m3 <- mspec_sub(m1, name = 'Model 3', pclass = fare)

m3

}
\concept{model specification functions}
